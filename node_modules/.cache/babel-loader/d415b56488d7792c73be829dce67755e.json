{"ast":null,"code":"var _jsxFileName = \"/Users/pranavchachra/Desktop/Algorithm-Visualizer/src/algorithms/QuickSort.js\";\nimport React from 'react';\nimport { swap, newTrace, addToTrace, lastSorted, createRange, createKey } from './helpers';\n\nconst QuickSort = nums => {\n  // Initial State\n  const trace = newTrace(nums);\n\n  function choosePivot(array, start, end) {\n    // randomly pick an element between start and end;\n    return Math.floor(Math.random() * (end - start)) + start;\n  }\n\n  function partition(array, start, end) {\n    let i = start + 1;\n    let j = start + 1; // Visualize: Keep pivot marked\n\n    addToTrace(trace, array, lastSorted(trace), [start]);\n\n    while (j <= end) {\n      if (array[j] < array[start]) {\n        // Visualize: Mark item that is less than pivot\n        addToTrace(trace, array, lastSorted(trace), [start], [j], [], createRange(start + 1, i));\n        swap(array, i, j); // Visualize: Move item to lesser list\n\n        addToTrace(trace, array, lastSorted(trace), [start], [i], [], createRange(start + 1, i));\n        i += 1;\n      }\n\n      j += 1;\n    } // Visualize: Mark center position\n\n\n    addToTrace(trace, array, lastSorted(trace), [i - 1], [], [], createRange(start, i - 1));\n    swap(array, start, i - 1); // Visualize: Move pivot to center\n\n    addToTrace(trace, array, lastSorted(trace), [i - 1], [], [], createRange(start, i - 1));\n    return i - 1;\n  }\n\n  function recursiveQuickSort(array, start, end) {\n    if (start >= end) {\n      if (start === end) {\n        // Visualize: Mark only item as sorted\n        addToTrace(trace, array, [...lastSorted(trace), start]);\n      }\n\n      return null;\n    }\n\n    let pivot = choosePivot(array, start, end); // Visualize: Mark chosen pivot\n\n    addToTrace(trace, array, lastSorted(trace), [pivot]);\n    swap(array, start, pivot); // Visualize: Move chosen pivot to start\n\n    addToTrace(trace, array, lastSorted(trace), [pivot]);\n    pivot = partition(array, start, end); // Visualize: Mark pivot after partition as sorted\n\n    addToTrace(trace, array, [...lastSorted(trace), pivot]);\n    recursiveQuickSort(array, start, pivot - 1);\n    recursiveQuickSort(array, pivot + 1, end);\n  }\n\n  recursiveQuickSort(nums, 0, nums.length - 1);\n  return trace;\n};\n\nexport const QuickSortKey = createKey('Comparing', 'Swapping', null, 'Less than pivot');\nexport const QuickSortDesc = {\n  title: 'Quick Sorting',\n  description: React.createElement(\"div\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 125\n    },\n    __self: this\n  }, React.createElement(\"p\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 126\n    },\n    __self: this\n  }, \"Quicksort is an efficient algorithm that makes use of divide and conquer strategy. Quick Sort picks an element as pivot and partitions the given array around the picked pivot.\"), React.createElement(\"ul\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 129\n    },\n    __self: this\n  }, React.createElement(\"li\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 130\n    },\n    __self: this\n  }, \"Further, the large array is divided into two arrays in which one holds values that are smaller than the specified value (Pivot), and another array holds the values that are greater than the pivot(equal values can go either way).\"), React.createElement(\"li\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 132\n    },\n    __self: this\n  }, \"Further, left and right sub-arrays are also partitioned using the same approach until single element remains in the sub-array.\")), React.createElement(\"p\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 136\n    },\n    __self: this\n  }, \"The base case of the recursion is an array of size zero or one, which is sorted by definition.\")),\n  worstCase: React.createElement(\"span\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 143\n    },\n    __self: this\n  }, \"O(\", React.createElement(\"em\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 144\n    },\n    __self: this\n  }, \"n\"), React.createElement(\"sup\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 145\n    },\n    __self: this\n  }, \"2\"), \")\"),\n  avgCase: React.createElement(\"span\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 149\n    },\n    __self: this\n  }, \"O(\", React.createElement(\"em\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 150\n    },\n    __self: this\n  }, \"n\"), \"log\", React.createElement(\"em\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 150\n    },\n    __self: this\n  }, \"n\"), \")\"),\n  bestCase: React.createElement(\"span\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 154\n    },\n    __self: this\n  }, \"O(\", React.createElement(\"em\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 155\n    },\n    __self: this\n  }, \"n\"), \"log\", React.createElement(\"em\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 155\n    },\n    __self: this\n  }, \"n\"), \")\"),\n  space: React.createElement(\"span\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 159\n    },\n    __self: this\n  }, \"O(log\", React.createElement(\"em\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 160\n    },\n    __self: this\n  }, \"n\"), \")\")\n};\nexport default QuickSort;","map":{"version":3,"sources":["/Users/pranavchachra/Desktop/Algorithm-Visualizer/src/algorithms/QuickSort.js"],"names":["React","swap","newTrace","addToTrace","lastSorted","createRange","createKey","QuickSort","nums","trace","choosePivot","array","start","end","Math","floor","random","partition","i","j","recursiveQuickSort","pivot","length","QuickSortKey","QuickSortDesc","title","description","worstCase","avgCase","bestCase","space"],"mappings":"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","sourcesContent":["import React from 'react';\nimport {\n  swap,\n  newTrace,\n  addToTrace,\n  lastSorted,\n  createRange,\n  createKey\n} from './helpers';\n\nconst QuickSort = (nums) => {\n  // Initial State\n  const trace = newTrace(nums);\n\n  function choosePivot(array, start, end) {\n    // randomly pick an element between start and end;\n    return Math.floor(Math.random() * (end - start)) + start;\n  }\n\n  function partition(array, start, end) {\n    let i = start + 1;\n    let j = start + 1;\n\n    // Visualize: Keep pivot marked\n    addToTrace(trace, array, lastSorted(trace), [start]);\n\n    while (j <= end) {\n      if (array[j] < array[start]) {\n        // Visualize: Mark item that is less than pivot\n        addToTrace(\n          trace,\n          array,\n          lastSorted(trace),\n          [start],\n          [j],\n          [],\n          createRange(start + 1, i)\n        );\n\n        swap(array, i, j);\n\n        // Visualize: Move item to lesser list\n        addToTrace(\n          trace,\n          array,\n          lastSorted(trace),\n          [start],\n          [i],\n          [],\n          createRange(start + 1, i)\n        );\n        i += 1;\n      }\n      j += 1;\n    }\n\n    // Visualize: Mark center position\n    addToTrace(\n      trace,\n      array,\n      lastSorted(trace),\n      [i - 1],\n      [],\n      [],\n      createRange(start, i - 1)\n    );\n    swap(array, start, i - 1);\n\n    // Visualize: Move pivot to center\n    addToTrace(\n      trace,\n      array,\n      lastSorted(trace),\n      [i - 1],\n      [],\n      [],\n      createRange(start, i - 1)\n    );\n    return i - 1;\n  }\n\n  function recursiveQuickSort(array, start, end) {\n    if (start >= end) {\n      if (start === end) {\n        // Visualize: Mark only item as sorted\n        addToTrace(trace, array, [...lastSorted(trace), start]);\n      }\n      return null;\n    }\n\n    let pivot = choosePivot(array, start, end);\n\n    // Visualize: Mark chosen pivot\n    addToTrace(trace, array, lastSorted(trace), [pivot]);\n\n    swap(array, start, pivot);\n\n    // Visualize: Move chosen pivot to start\n    addToTrace(trace, array, lastSorted(trace), [pivot]);\n\n    pivot = partition(array, start, end);\n\n    // Visualize: Mark pivot after partition as sorted\n    addToTrace(trace, array, [...lastSorted(trace), pivot]);\n\n    recursiveQuickSort(array, start, pivot - 1);\n    recursiveQuickSort(array, pivot + 1, end);\n  }\n\n  recursiveQuickSort(nums, 0, nums.length - 1);\n\n  return trace;\n};\n\nexport const QuickSortKey = createKey(\n  'Comparing',\n  'Swapping',\n  null,\n  'Less than pivot'\n);\n\nexport const QuickSortDesc = {\n  title: 'Quick Sorting',\n  description: (\n    <div>\n      <p>\n        Quicksort is an efficient algorithm that makes use of divide and conquer strategy. Quick Sort picks an element as pivot and partitions the given array around the picked pivot.\n      </p>\n      <ul>\n        <li>Further, the large array is divided into two arrays in which one holds values that are smaller than the specified value (Pivot), and another array holds the values that are greater than the pivot(equal values can go either way).\n        </li>\n        <li>\n        Further, left and right sub-arrays are also partitioned using the same approach until single element remains in the sub-array.\n        </li>\n      </ul>\n      <p>\n        The base case of the recursion is an array of size zero or one,\n        which is sorted by definition.\n      </p>\n    </div>\n  ),\n  worstCase: (\n    <span>\n      O(<em>n</em>\n      <sup>2</sup>)\n    </span>\n  ),\n  avgCase: (\n    <span>\n      O(<em>n</em>log<em>n</em>)\n    </span>\n  ),\n  bestCase: (\n    <span>\n      O(<em>n</em>log<em>n</em>)\n    </span>\n  ),\n  space: (\n    <span>\n      O(log<em>n</em>)\n    </span>\n  )\n};\n\nexport default QuickSort;"]},"metadata":{},"sourceType":"module"}