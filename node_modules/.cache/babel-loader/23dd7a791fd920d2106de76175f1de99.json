{"ast":null,"code":"var _jsxFileName = \"/Users/pranavchachra/Desktop/sort-visualizer-master/src/algorithms/HeapSort.js\";\nimport React from 'react';\nimport { swap, newTrace, addToTrace, lastSorted, createRange, createKey } from './helpers';\n\nconst HeapSort = nums => {\n  const trace = newTrace(nums);\n\n  const left = i => 2 * i + 1;\n\n  const right = i => 2 * i + 2;\n\n  const parent = i => Math.floor((i - 1) / 2);\n\n  const maxHeapify = (array, i, heapsize) => {\n    const leftChild = left(i);\n    const rightChild = right(i); // Visualize: Compare parent and leftChild\n\n    addToTrace(trace, array, lastSorted(trace), [i, leftChild]);\n    let largest = leftChild < heapsize && array[leftChild] > array[i] ? leftChild : i; // Visualize: Compare largest and rightChild\n\n    addToTrace(trace, array, lastSorted(trace), [largest, rightChild]);\n    if (rightChild < heapsize && array[rightChild] > array[largest]) largest = rightChild;\n\n    if (largest !== i) {\n      // Visualize: Select largest child and parent\n      addToTrace(trace, array, lastSorted(trace), [], [i, largest]);\n      swap(array, i, largest); // Visualize: Swap largest child and parent\n\n      addToTrace(trace, array, lastSorted(trace), [], [i, largest]);\n      maxHeapify(array, largest, heapsize);\n    }\n  };\n\n  const BuildMaxHeap = array => {\n    const start = Math.floor(array.length / 2);\n    const heapsize = array.length;\n\n    for (let i = start; i >= 0; i--) {\n      maxHeapify(array, i, heapsize);\n    } // Visualize: Mark heap as built\n\n\n    addToTrace(trace, array, lastSorted(trace), [], [], [], createRange(0, array.length));\n  };\n\n  const heapSort = array => {\n    BuildMaxHeap(array);\n    let heapsize = array.length;\n\n    for (let i = array.length - 1; i > 0; i--) {\n      // Visualize: Select Maximum\n      addToTrace(trace, array, lastSorted(trace), [], [0, i]);\n      swap(array, 0, i);\n      heapsize -= 1; // Visualize: Swap with last element in heap\n\n      addToTrace(trace, array, [...lastSorted(trace), i], [], [0, i]);\n      maxHeapify(array, 0, heapsize); // Visualize: Heap created\n\n      addToTrace(trace, array, lastSorted(trace), [], [], [], createRange(0, heapsize));\n    }\n\n    addToTrace(trace, array, [...lastSorted(trace), 0]);\n  }; // Execute Heapsort\n\n\n  heapSort(nums);\n  return trace;\n};\n\nexport const HeapSortKey = createKey('Comparing', 'Swapping', null, 'Heap Built');\nexport const HeapSortDesc = {\n  title: 'Heap Sorting',\n  description: React.createElement(\"div\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 112\n    },\n    __self: this\n  }, React.createElement(\"p\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 113\n    },\n    __self: this\n  }, \"Heap Sorting is a comparison-based [in-place] sorting algorithm that divides its input into a sorted and an unsorted region, just like Selection Sort and then iteratively shrinks the unsorted region by extracting the largest element from it and inserting it into the sorted region.\"), React.createElement(\"p\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 116\n    },\n    __self: this\n  }, \"The Heap Sort algorithm can be divided into following two parts:\"), React.createElement(\"ul\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 119\n    },\n    __self: this\n  }, React.createElement(\"li\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 120\n    },\n    __self: this\n  }, \"In the first step, a heap is built out of the data. The heap is often placed in an array with the layout of a complete binary tree.\"), React.createElement(\"li\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 124\n    },\n    __self: this\n  }, \"In the second step, a sorted array is created by repeatedly removing the largest element from the heap (the root of the heap), and inserting it into the array.\")), \"The heap is updated after each removal to maintain the heap property. Once all objects have been removed from the heap, the result is a sorted array.\"),\n  worstCase: React.createElement(\"span\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 136\n    },\n    __self: this\n  }, \"O(\", React.createElement(\"em\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 137\n    },\n    __self: this\n  }, \"n\"), \" log \", React.createElement(\"em\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 137\n    },\n    __self: this\n  }, \"n\"), \")\"),\n  avgCase: React.createElement(\"span\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 141\n    },\n    __self: this\n  }, \"O(\", React.createElement(\"em\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 142\n    },\n    __self: this\n  }, \"n\"), \" log \", React.createElement(\"em\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 142\n    },\n    __self: this\n  }, \"n\"), \")\"),\n  bestCase: React.createElement(\"span\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 146\n    },\n    __self: this\n  }, \"O(\", React.createElement(\"em\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 147\n    },\n    __self: this\n  }, \"n\"), \" log \", React.createElement(\"em\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 147\n    },\n    __self: this\n  }, \"n\"), \")\"),\n  space: React.createElement(\"span\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 150\n    },\n    __self: this\n  }, \"O(1)\")\n};\nexport default HeapSort;","map":{"version":3,"sources":["/Users/pranavchachra/Desktop/sort-visualizer-master/src/algorithms/HeapSort.js"],"names":["React","swap","newTrace","addToTrace","lastSorted","createRange","createKey","HeapSort","nums","trace","left","i","right","parent","Math","floor","maxHeapify","array","heapsize","leftChild","rightChild","largest","BuildMaxHeap","start","length","heapSort","HeapSortKey","HeapSortDesc","title","description","worstCase","avgCase","bestCase","space"],"mappings":"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","sourcesContent":["import React from 'react';\nimport {\n  swap,\n  newTrace,\n  addToTrace,\n  lastSorted,\n  createRange,\n  createKey\n} from './helpers';\n\nconst HeapSort = (nums) => {\n  const trace = newTrace(nums);\n\n  const left = (i) => 2 * i + 1;\n  const right = (i) => 2 * i + 2;\n  const parent = (i) => Math.floor((i - 1) / 2);\n\n  const maxHeapify = (array, i, heapsize) => {\n    const leftChild = left(i);\n    const rightChild = right(i);\n\n    // Visualize: Compare parent and leftChild\n    addToTrace(trace, array, lastSorted(trace), [i, leftChild]);\n\n    let largest =\n      leftChild < heapsize && array[leftChild] > array[i]\n        ? leftChild\n        : i;\n\n    // Visualize: Compare largest and rightChild\n    addToTrace(trace, array, lastSorted(trace), [largest, rightChild]);\n\n    if (rightChild < heapsize && array[rightChild] > array[largest])\n      largest = rightChild;\n\n    if (largest !== i) {\n      // Visualize: Select largest child and parent\n      addToTrace(trace, array, lastSorted(trace), [], [i, largest]);\n\n      swap(array, i, largest);\n\n      // Visualize: Swap largest child and parent\n      addToTrace(trace, array, lastSorted(trace), [], [i, largest]);\n\n      maxHeapify(array, largest, heapsize);\n    }\n  };\n\n  const BuildMaxHeap = (array) => {\n    const start = Math.floor(array.length / 2);\n    const heapsize = array.length;\n    for (let i = start; i >= 0; i--) {\n      maxHeapify(array, i, heapsize);\n    }\n\n    // Visualize: Mark heap as built\n    addToTrace(\n      trace,\n      array,\n      lastSorted(trace),\n      [],\n      [],\n      [],\n      createRange(0, array.length)\n    );\n  };\n\n  const heapSort = (array) => {\n    BuildMaxHeap(array);\n    let heapsize = array.length;\n    for (let i = array.length - 1; i > 0; i--) {\n      // Visualize: Select Maximum\n      addToTrace(trace, array, lastSorted(trace), [], [0, i]);\n\n      swap(array, 0, i);\n      heapsize -= 1;\n\n      // Visualize: Swap with last element in heap\n      addToTrace(trace, array, [...lastSorted(trace), i], [], [0, i]);\n\n      maxHeapify(array, 0, heapsize);\n\n      // Visualize: Heap created\n      addToTrace(\n        trace,\n        array,\n        lastSorted(trace),\n        [],\n        [],\n        [],\n        createRange(0, heapsize)\n      );\n    }\n    addToTrace(trace, array, [...lastSorted(trace), 0]);\n  };\n\n  // Execute Heapsort\n  heapSort(nums);\n  return trace;\n};\n\nexport const HeapSortKey = createKey(\n  'Comparing',\n  'Swapping',\n  null,\n  'Heap Built'\n);\n\nexport const HeapSortDesc = {\n  title: 'Heap Sorting',\n  description: (\n    <div>\n      <p>\n        Heap Sorting is a comparison-based [in-place] sorting algorithm that divides its input into a sorted and an unsorted region, just like Selection Sort and then iteratively shrinks the unsorted region by extracting the largest element from it and inserting it into the sorted region.\n      </p>\n      <p>\n        The Heap Sort algorithm can be divided into following two parts:\n      </p>\n      <ul>\n        <li>\n        In the first step, a heap is built out of the data. The heap is often\n        placed in an array with the layout of a complete binary tree.\n        </li>\n        <li>\n        In the second step, a sorted array is created by repeatedly\n        removing the largest element from the heap (the root of the\n        heap), and inserting it into the array.\n        </li>\n      </ul>\n        The heap is updated after each removal to maintain the heap property. \n        Once all objects have been removed from the heap, the result is a sorted\n        array.\n    </div>\n  ),\n  worstCase: (\n    <span>\n      O(<em>n</em> log <em>n</em>)\n    </span>\n  ),\n  avgCase: (\n    <span>\n      O(<em>n</em> log <em>n</em>)\n    </span>\n  ),\n  bestCase: (\n    <span>\n      O(<em>n</em> log <em>n</em>)\n    </span>\n  ),\n  space: <span>O(1)</span>\n};\n\nexport default HeapSort;"]},"metadata":{},"sourceType":"module"}