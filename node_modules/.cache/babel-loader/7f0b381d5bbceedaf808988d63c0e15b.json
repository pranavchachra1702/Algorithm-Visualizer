{"ast":null,"code":"import _toConsumableArray from\"/Users/pranavchachra/Desktop/algovisualizer/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import React from'react';import{newTrace,addToTrace,createKey}from'./helpers';var MergeSort=function MergeSort(nums){// Initial State\nvar trace=newTrace(nums);function merge(original,start,mid,end){var left=original.slice(start,mid);var right=original.slice(mid,end);var i=0;var j=0;var k=0;while(i<left.length&&j<right.length){if(left[i]<=right[j]){addToTrace(trace,original,[],[],[],[k+start]);original[k+start]=left[i];i++;addToTrace(trace,original,[],[],[],[k+start]);}else{addToTrace(trace,original,[],[],[],[k+start]);original[k+start]=right[j];j++;addToTrace(trace,original,[],[],[],[k+start]);}k++;}while(i<left.length){addToTrace(trace,original,[],[],[],[k+start]);original[k+start]=left[i];i++;k++;addToTrace(trace,original,[],[],[],[k+start]);}while(j<right.length){addToTrace(trace,original,[],[],[],[k+start]);original[k+start]=right[j];j++;k++;addToTrace(trace,original,[],[],[],[k+start]);}left.length=0;right.length=0;}function recursiveMergeSort(original,start,end){var length=end-start;if(length<2){// original = []\nif(length<1)return original;// original = [x]\nelse return[original[start]];}var midPoint=Math.floor((start+end)/2);// Visualize: First Half\naddToTrace(trace,original,[],_toConsumableArray(Array(midPoint-start).keys()).map(function(i){return i+start;}));recursiveMergeSort(original,start,midPoint);// Visualize: Second Half\naddToTrace(trace,original,[],_toConsumableArray(Array(end-midPoint).keys()).map(function(i){return i+midPoint;}));recursiveMergeSort(original,midPoint,end);merge(original,start,midPoint,end);}recursiveMergeSort(nums,0,nums.length);// Visualize: Mark all elements as sorted\naddToTrace(trace,nums,_toConsumableArray(Array(nums.length).keys()));return trace;};export var MergeSortKey=createKey('Call Merge Sort',null,'Overwrite from auxilary array');export var MergeSortDesc={title:'Merge Sorting',description:React.createElement(\"div\",null,React.createElement(\"p\",null,\"Merge Sorting is an efficient, stable sorting algorithm that makes use of the divide and conquer strategy. Conceptually the algorithm works as follows:\"),React.createElement(\"ol\",null,React.createElement(\"li\",null,\"Divide the unsorted list into \",React.createElement(\"em\",null,\"n\"),\" sublists, each containing one element(a list of one element is considered sorted)\"),React.createElement(\"li\",null,\"Repeatedly merge sublists to produce new sorted sublists until there is only one sublist remaining. This will be the sorted list.\"))),worstCase:React.createElement(\"span\",null,\"O(\",React.createElement(\"em\",null,\"n\"),\" log \",React.createElement(\"em\",null,\"n\"),\")\"),avgCase:React.createElement(\"span\",null,\"O(\",React.createElement(\"em\",null,\"n\"),\" log \",React.createElement(\"em\",null,\"n\"),\")\"),bestCase:React.createElement(\"span\",null,\"O(\",React.createElement(\"em\",null,\"n\"),\" log \",React.createElement(\"em\",null,\"n\"),\")\"),space:React.createElement(\"span\",null,\"O(\",React.createElement(\"em\",null,\"n\"),\")\")};export default MergeSort;","map":{"version":3,"sources":["/Users/pranavchachra/Desktop/algovisualizer/src/algorithms/MergeSort.js"],"names":["React","newTrace","addToTrace","createKey","MergeSort","nums","trace","merge","original","start","mid","end","left","slice","right","i","j","k","length","recursiveMergeSort","midPoint","Math","floor","Array","keys","map","MergeSortKey","MergeSortDesc","title","description","worstCase","avgCase","bestCase","space"],"mappings":"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","sourcesContent":["import React from 'react';\nimport { newTrace, addToTrace, createKey } from './helpers';\n\nconst MergeSort = (nums) => {\n  // Initial State\n  const trace = newTrace(nums);\n\n  function merge(original, start, mid, end) {\n    const left = original.slice(start, mid);\n    const right = original.slice(mid, end);\n    let i = 0;\n    let j = 0;\n    let k = 0;\n    while (i < left.length && j < right.length) {\n      if (left[i] <= right[j]) {\n        addToTrace(trace, original, [], [], [], [k + start]);\n        original[k + start] = left[i];\n        i++;\n        addToTrace(trace, original, [], [], [], [k + start]);\n      } else {\n        addToTrace(trace, original, [], [], [], [k + start]);\n        original[k + start] = right[j];\n        j++;\n        addToTrace(trace, original, [], [], [], [k + start]);\n      }\n      k++;\n    }\n    while (i < left.length) {\n      addToTrace(trace, original, [], [], [], [k + start]);\n      original[k + start] = left[i];\n      i++;\n      k++;\n      addToTrace(trace, original, [], [], [], [k + start]);\n    }\n    while (j < right.length) {\n      addToTrace(trace, original, [], [], [], [k + start]);\n      original[k + start] = right[j];\n      j++;\n      k++;\n      addToTrace(trace, original, [], [], [], [k + start]);\n    }\n\n    left.length = 0;\n    right.length = 0;\n  }\n\n  function recursiveMergeSort(original, start, end) {\n    const length = end - start;\n    if (length < 2) {\n      // original = []\n      if (length < 1) return original;\n      // original = [x]\n      else return [original[start]];\n    }\n\n    const midPoint = Math.floor((start + end) / 2);\n\n    // Visualize: First Half\n    addToTrace(\n      trace,\n      original,\n      [],\n      [...Array(midPoint - start).keys()].map((i) => i + start)\n    );\n    recursiveMergeSort(original, start, midPoint);\n\n    // Visualize: Second Half\n    addToTrace(\n      trace,\n      original,\n      [],\n      [...Array(end - midPoint).keys()].map((i) => i + midPoint)\n    );\n    recursiveMergeSort(original, midPoint, end);\n\n    merge(original, start, midPoint, end);\n  }\n\n  recursiveMergeSort(nums, 0, nums.length);\n\n  // Visualize: Mark all elements as sorted\n  addToTrace(trace, nums, [...Array(nums.length).keys()]);\n  return trace;\n};\n\nexport const MergeSortKey = createKey(\n  'Call Merge Sort',\n  null,\n  'Overwrite from auxilary array'\n);\nexport const MergeSortDesc = {\n  title: 'Merge Sorting',\n  description: (\n    <div>\n      <p>\n        Merge Sorting is an efficient, stable sorting algorithm that makes use of the\n        divide and conquer strategy. Conceptually the algorithm works as\n        follows:\n      </p>\n      <ol>\n        <li>\n          Divide the unsorted list into <em>n</em> sublists, each\n          containing one element(a list of one element is considered\n          sorted)\n        </li>\n        <li>\n          Repeatedly merge sublists to produce new sorted sublists until\n          there is only one sublist remaining. This will be the sorted\n          list.\n        </li>\n      </ol>\n    </div>\n  ),\n  worstCase: (\n    <span>\n      O(<em>n</em> log <em>n</em>)\n    </span>\n  ),\n  avgCase: (\n    <span>\n      O(<em>n</em> log <em>n</em>)\n    </span>\n  ),\n  bestCase: (\n    <span>\n      O(<em>n</em> log <em>n</em>)\n    </span>\n  ),\n  space: (\n    <span>\n      O(<em>n</em>)\n    </span>\n  )\n};\nexport default MergeSort;"]},"metadata":{},"sourceType":"module"}