{"ast":null,"code":"import _slicedToArray from \"/Users/pranavchachra/Desktop/sort-visualizer-master/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nvar _jsxFileName = \"/Users/pranavchachra/Desktop/sort-visualizer-master/src/algorithms/QuickSort3.js\";\nimport React from 'react';\nimport { swap, newTrace, addToTrace, lastSorted, createRange, createKey } from './helpers';\n\nconst QuickSort3 = nums => {\n  // Initial State\n  const trace = newTrace(nums);\n\n  function choosePivot(array, start, end) {\n    // randomly pick an element between start and end;\n    return Math.floor(Math.random() * (end - start)) + start;\n  }\n\n  function partition(array, start, end) {\n    const pivot = array[start];\n    let i = start + 1;\n    let j = start + 1;\n    let k = start + 1; // Between k and end : uncheked\n    // Between start and i : equal to pivot\n    // Between i and j : less than pivot\n    // Between j and k : greater than pivot\n    // Visualize: Keep pivot marked\n\n    addToTrace(trace, array, lastSorted(trace), [start]);\n\n    while (k < end) {\n      if (array[k] === pivot) {\n        // Visualize: Mark item that is equal to pivot\n        addToTrace(trace, array, lastSorted(trace), [start, ...createRange(start, i)], [k], [], createRange(i, j));\n        swap(array, i, k); // Visualize: Mark item that is equal to pivot\n\n        addToTrace(trace, array, lastSorted(trace), [start, ...createRange(start, i)], [i], [], createRange(i, j));\n        if (j > i) swap(array, j, k);\n        i += 1;\n        j += 1;\n      } else if (array[k] < pivot) {\n        // Visualize: Mark item that is less than pivot\n        addToTrace(trace, array, lastSorted(trace), [start, ...createRange(start, i)], [k], [], createRange(i, j));\n        swap(array, j, k); // Visualize: Move item to lesser list\n\n        addToTrace(trace, array, lastSorted(trace), [start, ...createRange(start, i)], [j], [], createRange(i, j));\n        j += 1;\n      }\n\n      k += 1;\n    }\n\n    const pivot_elements = i - start;\n    i -= 1;\n    j -= 1;\n\n    while (i >= start) {\n      swap(array, i, j);\n      i -= 1;\n      j -= 1;\n    } // Visualize: Move pivot_elements to center\n\n\n    addToTrace(trace, array, lastSorted(trace), createRange(j + 1, j + 1 + pivot_elements), [], [], createRange(start, j + 1));\n    return [j + 1, j + 1 + pivot_elements];\n  }\n\n  function recursiveQuickSort3(array, start, end) {\n    if (start >= end - 1) {\n      if (start === end - 1) {\n        // Visualize: Mark only item as sorted\n        addToTrace(trace, array, [...lastSorted(trace), start]);\n      }\n\n      return null;\n    }\n\n    let pivot = choosePivot(array, start, end); // Visualize: Mark chosen pivot\n\n    addToTrace(trace, array, lastSorted(trace), [pivot]);\n    swap(array, start, pivot); // Visualize: Move chosen pivot to start\n\n    addToTrace(trace, array, lastSorted(trace), [pivot]);\n\n    let _partition = partition(array, start, end),\n        _partition2 = _slicedToArray(_partition, 2),\n        pivotStart = _partition2[0],\n        pivotEnd = _partition2[1]; // Visualize: Mark pivot after partition as sorted\n\n\n    addToTrace(trace, array, [...lastSorted(trace), ...createRange(pivotStart, pivotEnd)]);\n    recursiveQuickSort3(array, start, pivotStart);\n    recursiveQuickSort3(array, pivotEnd, end);\n  }\n\n  recursiveQuickSort3(nums, 0, nums.length);\n  return trace;\n};\n\nexport const QuickSort3Key = createKey('Comparing', 'Swapping', null, 'Less than pivot');\nexport const QuickSort3Desc = {\n  title: 'Quick Sort 3-Way Partitioning',\n  description: React.createElement(\"div\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 160\n    },\n    __self: this\n  }, React.createElement(\"p\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 161\n    },\n    __self: this\n  }, React.createElement(\"a\", {\n    href: \"https://en.wikipedia.org/wiki/Quicksort#Repeated_elements\",\n    target: \"_blank\",\n    rel: \"noopener noreferrer\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 162\n    },\n    __self: this\n  }, \"Quick Sort\"), ' ', \"exhibits poor performance on arrays that contain many repeated elements. This issue (\", React.createElement(\"a\", {\n    href: \"https://en.wikipedia.org/wiki/Dutch_national_flag_problem\",\n    target: \"_blank\",\n    rel: \"noopener noreferrer\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 171\n    },\n    __self: this\n  }, \"Dutch national flag problem\"), \") can be solved by using an alternative linear-time partitioning routine that separates the values into three groups: values less than the pivot, values equal to the pivot, and values greater than the pivot. The values equal to the pivot are already sorted, so only the less-than and greater-than partitions need to be recursively sorted.\")),\n  worstCase: React.createElement(\"span\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 188\n    },\n    __self: this\n  }, \"O(\", React.createElement(\"em\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 189\n    },\n    __self: this\n  }, \"n\"), React.createElement(\"sup\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 190\n    },\n    __self: this\n  }, \"2\"), \")\"),\n  avgCase: React.createElement(\"span\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 194\n    },\n    __self: this\n  }, \"O(\", React.createElement(\"em\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 195\n    },\n    __self: this\n  }, \"n\"), \" log \", React.createElement(\"em\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 195\n    },\n    __self: this\n  }, \"n\"), \")\"),\n  bestCase: React.createElement(\"span\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 199\n    },\n    __self: this\n  }, \"O(\", React.createElement(\"em\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 200\n    },\n    __self: this\n  }, \"n\"), \")\"),\n  space: React.createElement(\"span\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 204\n    },\n    __self: this\n  }, \"O(log \", React.createElement(\"em\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 205\n    },\n    __self: this\n  }, \"n\"), \")\")\n};\nexport default QuickSort3;","map":{"version":3,"sources":["/Users/pranavchachra/Desktop/sort-visualizer-master/src/algorithms/QuickSort3.js"],"names":["React","swap","newTrace","addToTrace","lastSorted","createRange","createKey","QuickSort3","nums","trace","choosePivot","array","start","end","Math","floor","random","partition","pivot","i","j","k","pivot_elements","recursiveQuickSort3","pivotStart","pivotEnd","length","QuickSort3Key","QuickSort3Desc","title","description","worstCase","avgCase","bestCase","space"],"mappings":"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","sourcesContent":["import React from 'react';\nimport {\n  swap,\n  newTrace,\n  addToTrace,\n  lastSorted,\n  createRange,\n  createKey\n} from './helpers';\n\nconst QuickSort3 = (nums) => {\n  // Initial State\n  const trace = newTrace(nums);\n\n  function choosePivot(array, start, end) {\n    // randomly pick an element between start and end;\n    return Math.floor(Math.random() * (end - start)) + start;\n  }\n\n  function partition(array, start, end) {\n    const pivot = array[start];\n    let i = start + 1;\n    let j = start + 1;\n    let k = start + 1;\n    // Between k and end : uncheked\n    // Between start and i : equal to pivot\n    // Between i and j : less than pivot\n    // Between j and k : greater than pivot\n\n    // Visualize: Keep pivot marked\n    addToTrace(trace, array, lastSorted(trace), [start]);\n\n    while (k < end) {\n      if (array[k] === pivot) {\n        // Visualize: Mark item that is equal to pivot\n        addToTrace(\n          trace,\n          array,\n          lastSorted(trace),\n          [start, ...createRange(start, i)],\n          [k],\n          [],\n          createRange(i, j)\n        );\n\n        swap(array, i, k);\n\n        // Visualize: Mark item that is equal to pivot\n        addToTrace(\n          trace,\n          array,\n          lastSorted(trace),\n          [start, ...createRange(start, i)],\n          [i],\n          [],\n          createRange(i, j)\n        );\n\n        if (j > i) swap(array, j, k);\n        i += 1;\n        j += 1;\n      } else if (array[k] < pivot) {\n        // Visualize: Mark item that is less than pivot\n        addToTrace(\n          trace,\n          array,\n          lastSorted(trace),\n          [start, ...createRange(start, i)],\n          [k],\n          [],\n          createRange(i, j)\n        );\n\n        swap(array, j, k);\n\n        // Visualize: Move item to lesser list\n        addToTrace(\n          trace,\n          array,\n          lastSorted(trace),\n          [start, ...createRange(start, i)],\n          [j],\n          [],\n          createRange(i, j)\n        );\n\n        j += 1;\n      }\n      k += 1;\n    }\n\n    const pivot_elements = i - start;\n    i -= 1;\n    j -= 1;\n    while (i >= start) {\n      swap(array, i, j);\n      i -= 1;\n      j -= 1;\n    }\n\n    // Visualize: Move pivot_elements to center\n    addToTrace(\n      trace,\n      array,\n      lastSorted(trace),\n      createRange(j + 1, j + 1 + pivot_elements),\n      [],\n      [],\n      createRange(start, j + 1)\n    );\n    return [j + 1, j + 1 + pivot_elements];\n  }\n\n  function recursiveQuickSort3(array, start, end) {\n    if (start >= end - 1) {\n      if (start === end - 1) {\n        // Visualize: Mark only item as sorted\n        addToTrace(trace, array, [...lastSorted(trace), start]);\n      }\n      return null;\n    }\n\n    let pivot = choosePivot(array, start, end);\n\n    // Visualize: Mark chosen pivot\n    addToTrace(trace, array, lastSorted(trace), [pivot]);\n\n    swap(array, start, pivot);\n\n    // Visualize: Move chosen pivot to start\n    addToTrace(trace, array, lastSorted(trace), [pivot]);\n\n    let [pivotStart, pivotEnd] = partition(array, start, end);\n\n    // Visualize: Mark pivot after partition as sorted\n    addToTrace(trace, array, [\n      ...lastSorted(trace),\n      ...createRange(pivotStart, pivotEnd)\n    ]);\n\n    recursiveQuickSort3(array, start, pivotStart);\n    recursiveQuickSort3(array, pivotEnd, end);\n  }\n\n  recursiveQuickSort3(nums, 0, nums.length);\n\n  return trace;\n};\n\nexport const QuickSort3Key = createKey(\n  'Comparing',\n  'Swapping',\n  null,\n  'Less than pivot'\n);\n\nexport const QuickSort3Desc = {\n  title: 'Quick Sort 3-Way Partitioning',\n  description: (\n    <div>\n      <p>\n        <a\n          href=\"https://en.wikipedia.org/wiki/Quicksort#Repeated_elements\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          Quick Sort\n        </a>{' '}\n        exhibits poor performance on arrays that contain many repeated\n        elements. This issue (\n        <a\n          href=\"https://en.wikipedia.org/wiki/Dutch_national_flag_problem\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          Dutch national flag problem\n        </a>\n        ) can be solved by using an alternative linear-time partitioning\n        routine that separates the values into three groups: values less\n        than the pivot, values equal to the pivot, and values greater\n        than the pivot. The values equal to the pivot are already\n        sorted, so only the less-than and greater-than partitions need\n        to be recursively sorted.\n      </p>\n    </div>\n  ),\n  worstCase: (\n    <span>\n      O(<em>n</em>\n      <sup>2</sup>)\n    </span>\n  ),\n  avgCase: (\n    <span>\n      O(<em>n</em> log <em>n</em>)\n    </span>\n  ),\n  bestCase: (\n    <span>\n      O(<em>n</em>)\n    </span>\n  ),\n  space: (\n    <span>\n      O(log <em>n</em>)\n    </span>\n  )\n};\n\nexport default QuickSort3;\n"]},"metadata":{},"sourceType":"module"}