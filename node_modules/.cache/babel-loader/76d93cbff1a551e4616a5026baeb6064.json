{"ast":null,"code":"import _toConsumableArray from\"/Users/pranavchachra/Desktop/algovisualizer/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import React from'react';import{newTrace,addToTrace,createKey}from'./helpers';var InsertionSort=function InsertionSort(nums){// Initial State\nvar trace=newTrace(nums);// Core Algorithm\nfor(var i=1;i<nums.length;i++){var value=nums[i];var hole=i;// Visualize: Hole has been selected for comparison\naddToTrace(trace,nums,[],[i]);while(hole>0&&nums[hole-1]>value){// Visualize: Compare hole to value\naddToTrace(trace,nums,[],[hole],[hole-1]);nums[hole]=nums[hole-1];hole-=1;// Visualize: Overwrite hole with hole - 1\naddToTrace(trace,nums,[],[],[hole,hole+1]);}// Visualize: Overwrite hole with value\naddToTrace(trace,nums,[],[],[],[hole]);nums[hole]=value;// Visualize: value is in sorted position\naddToTrace(trace,nums,[],[],[],[hole]);}// Visualize: Mark all elements as sorted\naddToTrace(trace,nums,_toConsumableArray(Array(nums.length).keys()));return trace;};export var InsertionSortKey=createKey('Comparing','Swapping','Overwrite from memory');export var InsertionSortDesc={title:'Insertion Sorting',description:React.createElement(\"p\",null,\"Insertion Sorting is a in-place comparison based sorting algorithm. In this technique, the array is virtually split into a sorted and an unsorted part.\",React.createElement(\"ul\",null,React.createElement(\"li\",null,\"The array is virtually split into a sorted and an unsorted part.\"),React.createElement(\"li\",null,\"The technique iterates through the array and at each iteration it removes one element from the unsorted part of the array, finds the location it belongs to in the sorted list and inserts it there, repeating until no elements remain in the unsorted list\")),\"It is more efficient in practice compared to other quadratic sorting algorithms like bubble sort and selection sort but is not appropriate for large data sets .\"),worstCase:React.createElement(\"span\",null,\"O(n\",React.createElement(\"sup\",null,\"2\"),\")\"),avgCase:React.createElement(\"span\",null,\"O(n\",React.createElement(\"sup\",null,\"2\"),\")\"),bestCase:React.createElement(\"span\",null,\"O(n)\"),space:React.createElement(\"span\",null,\"O(1)\")};export default InsertionSort;","map":{"version":3,"sources":["/Users/pranavchachra/Desktop/algovisualizer/src/algorithms/InsertionSort.js"],"names":["React","newTrace","addToTrace","createKey","InsertionSort","nums","trace","i","length","value","hole","Array","keys","InsertionSortKey","InsertionSortDesc","title","description","worstCase","avgCase","bestCase","space"],"mappings":"sIAAA,MAAOA,CAAAA,KAAP,KAAkB,OAAlB,CACA,OAASC,QAAT,CAAmBC,UAAnB,CAA+BC,SAA/B,KAAgD,WAAhD,CAEA,GAAMC,CAAAA,aAAa,CAAG,QAAhBA,CAAAA,aAAgB,CAACC,IAAD,CAAU,CAC9B;AACA,GAAMC,CAAAA,KAAK,CAAGL,QAAQ,CAACI,IAAD,CAAtB,CAEA;AACA,IAAK,GAAIE,CAAAA,CAAC,CAAG,CAAb,CAAgBA,CAAC,CAAGF,IAAI,CAACG,MAAzB,CAAiCD,CAAC,EAAlC,CAAsC,CACpC,GAAIE,CAAAA,KAAK,CAAGJ,IAAI,CAACE,CAAD,CAAhB,CACA,GAAIG,CAAAA,IAAI,CAAGH,CAAX,CACA;AACAL,UAAU,CAACI,KAAD,CAAQD,IAAR,CAAc,EAAd,CAAkB,CAACE,CAAD,CAAlB,CAAV,CACA,MAAOG,IAAI,CAAG,CAAP,EAAYL,IAAI,CAACK,IAAI,CAAG,CAAR,CAAJ,CAAiBD,KAApC,CAA2C,CACzC;AACAP,UAAU,CAACI,KAAD,CAAQD,IAAR,CAAc,EAAd,CAAkB,CAACK,IAAD,CAAlB,CAA0B,CAACA,IAAI,CAAG,CAAR,CAA1B,CAAV,CACAL,IAAI,CAACK,IAAD,CAAJ,CAAaL,IAAI,CAACK,IAAI,CAAG,CAAR,CAAjB,CACAA,IAAI,EAAI,CAAR,CACA;AACAR,UAAU,CAACI,KAAD,CAAQD,IAAR,CAAc,EAAd,CAAkB,EAAlB,CAAsB,CAACK,IAAD,CAAOA,IAAI,CAAG,CAAd,CAAtB,CAAV,CACD,CACD;AACAR,UAAU,CAACI,KAAD,CAAQD,IAAR,CAAc,EAAd,CAAkB,EAAlB,CAAsB,EAAtB,CAA0B,CAACK,IAAD,CAA1B,CAAV,CACAL,IAAI,CAACK,IAAD,CAAJ,CAAaD,KAAb,CACA;AACAP,UAAU,CAACI,KAAD,CAAQD,IAAR,CAAc,EAAd,CAAkB,EAAlB,CAAsB,EAAtB,CAA0B,CAACK,IAAD,CAA1B,CAAV,CACD,CAED;AACAR,UAAU,CAACI,KAAD,CAAQD,IAAR,oBAAkBM,KAAK,CAACN,IAAI,CAACG,MAAN,CAAL,CAAmBI,IAAnB,EAAlB,EAAV,CACA,MAAON,CAAAA,KAAP,CACD,CA5BD,CA8BA,MAAO,IAAMO,CAAAA,gBAAgB,CAAGV,SAAS,CACvC,WADuC,CAEvC,UAFuC,CAGvC,uBAHuC,CAAlC,CAKP,MAAO,IAAMW,CAAAA,iBAAiB,CAAG,CAC/BC,KAAK,CAAE,mBADwB,CAE/BC,WAAW,CACT,uLAEE,8BACE,iGADF,CAIE,6RAJF,CAFF,oKAH6B,CAiB/BC,SAAS,CACP,sCACK,mCADL,KAlB6B,CAsB/BC,OAAO,CACL,sCACK,mCADL,KAvB6B,CA2B/BC,QAAQ,CAAE,uCA3BqB,CA4B/BC,KAAK,CAAE,uCA5BwB,CAA1B,CA+BP,cAAehB,CAAAA,aAAf","sourcesContent":["import React from 'react';\nimport { newTrace, addToTrace, createKey } from './helpers';\n\nconst InsertionSort = (nums) => {\n  // Initial State\n  const trace = newTrace(nums);\n\n  // Core Algorithm\n  for (let i = 1; i < nums.length; i++) {\n    let value = nums[i];\n    let hole = i;\n    // Visualize: Hole has been selected for comparison\n    addToTrace(trace, nums, [], [i]);\n    while (hole > 0 && nums[hole - 1] > value) {\n      // Visualize: Compare hole to value\n      addToTrace(trace, nums, [], [hole], [hole - 1]);\n      nums[hole] = nums[hole - 1];\n      hole -= 1;\n      // Visualize: Overwrite hole with hole - 1\n      addToTrace(trace, nums, [], [], [hole, hole + 1]);\n    }\n    // Visualize: Overwrite hole with value\n    addToTrace(trace, nums, [], [], [], [hole]);\n    nums[hole] = value;\n    // Visualize: value is in sorted position\n    addToTrace(trace, nums, [], [], [], [hole]);\n  }\n\n  // Visualize: Mark all elements as sorted\n  addToTrace(trace, nums, [...Array(nums.length).keys()]);\n  return trace;\n};\n\nexport const InsertionSortKey = createKey(\n  'Comparing',\n  'Swapping',\n  'Overwrite from memory'\n);\nexport const InsertionSortDesc = {\n  title: 'Insertion Sorting',\n  description: (\n    <p>\n      Insertion Sorting is a in-place comparison based sorting algorithm. In this technique, the array is virtually split into a sorted and an unsorted part. \n      <ul>\n        <li>\n        The array is virtually split into a sorted and an unsorted part.\n        </li>\n        <li>\n        The technique iterates through the array and at each iteration it removes one element from the unsorted part of the array, finds the location it belongs to in the sorted list and inserts it there, repeating until no elements remain in the unsorted list\n        </li>\n      </ul>\n      It is more efficient in practice compared to other quadratic\n      sorting algorithms like bubble sort and selection sort but is not appropriate for large data sets .\n    </p>\n  ),\n  worstCase: (\n    <span>\n      O(n<sup>2</sup>)\n    </span>\n  ),\n  avgCase: (\n    <span>\n      O(n<sup>2</sup>)\n    </span>\n  ),\n  bestCase: <span>O(n)</span>,\n  space: <span>O(1)</span>\n};\n\nexport default InsertionSort;"]},"metadata":{},"sourceType":"module"}