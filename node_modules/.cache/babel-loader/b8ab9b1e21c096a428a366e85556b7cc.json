{"ast":null,"code":"var _jsxFileName = \"/Users/pranavchachra/Desktop/sort-visualizer-master/src/algorithms/MergeSort.js\";\nimport React from 'react';\nimport { newTrace, addToTrace, createKey } from './helpers';\n\nconst MergeSort = nums => {\n  // Initial State\n  const trace = newTrace(nums);\n\n  function merge(original, start, mid, end) {\n    const left = original.slice(start, mid);\n    const right = original.slice(mid, end);\n    let i = 0;\n    let j = 0;\n    let k = 0;\n\n    while (i < left.length && j < right.length) {\n      if (left[i] <= right[j]) {\n        addToTrace(trace, original, [], [], [], [k + start]);\n        original[k + start] = left[i];\n        i++;\n        addToTrace(trace, original, [], [], [], [k + start]);\n      } else {\n        addToTrace(trace, original, [], [], [], [k + start]);\n        original[k + start] = right[j];\n        j++;\n        addToTrace(trace, original, [], [], [], [k + start]);\n      }\n\n      k++;\n    }\n\n    while (i < left.length) {\n      addToTrace(trace, original, [], [], [], [k + start]);\n      original[k + start] = left[i];\n      i++;\n      k++;\n      addToTrace(trace, original, [], [], [], [k + start]);\n    }\n\n    while (j < right.length) {\n      addToTrace(trace, original, [], [], [], [k + start]);\n      original[k + start] = right[j];\n      j++;\n      k++;\n      addToTrace(trace, original, [], [], [], [k + start]);\n    }\n\n    left.length = 0;\n    right.length = 0;\n  }\n\n  function recursiveMergeSort(original, start, end) {\n    const length = end - start;\n\n    if (length < 2) {\n      // original = []\n      if (length < 1) return original; // original = [x]\n      else return [original[start]];\n    }\n\n    const midPoint = Math.floor((start + end) / 2); // Visualize: First Half\n\n    addToTrace(trace, original, [], [...Array(midPoint - start).keys()].map(i => i + start));\n    recursiveMergeSort(original, start, midPoint); // Visualize: Second Half\n\n    addToTrace(trace, original, [], [...Array(end - midPoint).keys()].map(i => i + midPoint));\n    recursiveMergeSort(original, midPoint, end);\n    merge(original, start, midPoint, end);\n  }\n\n  recursiveMergeSort(nums, 0, nums.length); // Visualize: Mark all elements as sorted\n\n  addToTrace(trace, nums, [...Array(nums.length).keys()]);\n  return trace;\n};\n\nexport const MergeSortKey = createKey('Call Merge Sort', null, 'Overwrite from auxilary array');\nexport const MergeSortDesc = {\n  title: 'Merge Sorting',\n  description: React.createElement(\"div\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 94\n    },\n    __self: this\n  }, React.createElement(\"p\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 95\n    },\n    __self: this\n  }, \"Merge Sorting is an efficient, stable sorting algorithm that makes use of the divide and conquer strategy. Conceptually the algorithm works as follows:\"), React.createElement(\"ol\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 100\n    },\n    __self: this\n  }, React.createElement(\"li\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 101\n    },\n    __self: this\n  }, \"Divide the unsorted list into \", React.createElement(\"em\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 102\n    },\n    __self: this\n  }, \"n\"), \" sublists, each containing one element(a list of one element is considered sorted)\"), React.createElement(\"li\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 106\n    },\n    __self: this\n  }, \"Repeatedly merge sublists to produce new sorted sublists until there is only one sublist remaining. This will be the sorted list.\"))),\n  worstCase: React.createElement(\"span\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 115\n    },\n    __self: this\n  }, \"O(\", React.createElement(\"em\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 116\n    },\n    __self: this\n  }, \"n\"), \" log \", React.createElement(\"em\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 116\n    },\n    __self: this\n  }, \"n\"), \")\"),\n  avgCase: React.createElement(\"span\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 120\n    },\n    __self: this\n  }, \"O(\", React.createElement(\"em\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 121\n    },\n    __self: this\n  }, \"n\"), \" log \", React.createElement(\"em\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 121\n    },\n    __self: this\n  }, \"n\"), \")\"),\n  bestCase: React.createElement(\"span\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 125\n    },\n    __self: this\n  }, \"O(\", React.createElement(\"em\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 126\n    },\n    __self: this\n  }, \"n\"), \" log \", React.createElement(\"em\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 126\n    },\n    __self: this\n  }, \"n\"), \")\"),\n  space: React.createElement(\"span\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 130\n    },\n    __self: this\n  }, \"O(\", React.createElement(\"em\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 131\n    },\n    __self: this\n  }, \"n\"), \")\")\n};\nexport default MergeSort;","map":{"version":3,"sources":["/Users/pranavchachra/Desktop/sort-visualizer-master/src/algorithms/MergeSort.js"],"names":["React","newTrace","addToTrace","createKey","MergeSort","nums","trace","merge","original","start","mid","end","left","slice","right","i","j","k","length","recursiveMergeSort","midPoint","Math","floor","Array","keys","map","MergeSortKey","MergeSortDesc","title","description","worstCase","avgCase","bestCase","space"],"mappings":"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","sourcesContent":["import React from 'react';\nimport { newTrace, addToTrace, createKey } from './helpers';\n\nconst MergeSort = (nums) => {\n  // Initial State\n  const trace = newTrace(nums);\n\n  function merge(original, start, mid, end) {\n    const left = original.slice(start, mid);\n    const right = original.slice(mid, end);\n    let i = 0;\n    let j = 0;\n    let k = 0;\n    while (i < left.length && j < right.length) {\n      if (left[i] <= right[j]) {\n        addToTrace(trace, original, [], [], [], [k + start]);\n        original[k + start] = left[i];\n        i++;\n        addToTrace(trace, original, [], [], [], [k + start]);\n      } else {\n        addToTrace(trace, original, [], [], [], [k + start]);\n        original[k + start] = right[j];\n        j++;\n        addToTrace(trace, original, [], [], [], [k + start]);\n      }\n      k++;\n    }\n    while (i < left.length) {\n      addToTrace(trace, original, [], [], [], [k + start]);\n      original[k + start] = left[i];\n      i++;\n      k++;\n      addToTrace(trace, original, [], [], [], [k + start]);\n    }\n    while (j < right.length) {\n      addToTrace(trace, original, [], [], [], [k + start]);\n      original[k + start] = right[j];\n      j++;\n      k++;\n      addToTrace(trace, original, [], [], [], [k + start]);\n    }\n\n    left.length = 0;\n    right.length = 0;\n  }\n\n  function recursiveMergeSort(original, start, end) {\n    const length = end - start;\n    if (length < 2) {\n      // original = []\n      if (length < 1) return original;\n      // original = [x]\n      else return [original[start]];\n    }\n\n    const midPoint = Math.floor((start + end) / 2);\n\n    // Visualize: First Half\n    addToTrace(\n      trace,\n      original,\n      [],\n      [...Array(midPoint - start).keys()].map((i) => i + start)\n    );\n    recursiveMergeSort(original, start, midPoint);\n\n    // Visualize: Second Half\n    addToTrace(\n      trace,\n      original,\n      [],\n      [...Array(end - midPoint).keys()].map((i) => i + midPoint)\n    );\n    recursiveMergeSort(original, midPoint, end);\n\n    merge(original, start, midPoint, end);\n  }\n\n  recursiveMergeSort(nums, 0, nums.length);\n\n  // Visualize: Mark all elements as sorted\n  addToTrace(trace, nums, [...Array(nums.length).keys()]);\n  return trace;\n};\n\nexport const MergeSortKey = createKey(\n  'Call Merge Sort',\n  null,\n  'Overwrite from auxilary array'\n);\nexport const MergeSortDesc = {\n  title: 'Merge Sorting',\n  description: (\n    <div>\n      <p>\n        Merge Sorting is an efficient, stable sorting algorithm that makes use of the\n        divide and conquer strategy. Conceptually the algorithm works as\n        follows:\n      </p>\n      <ol>\n        <li>\n          Divide the unsorted list into <em>n</em> sublists, each\n          containing one element(a list of one element is considered\n          sorted)\n        </li>\n        <li>\n          Repeatedly merge sublists to produce new sorted sublists until\n          there is only one sublist remaining. This will be the sorted\n          list.\n        </li>\n      </ol>\n    </div>\n  ),\n  worstCase: (\n    <span>\n      O(<em>n</em> log <em>n</em>)\n    </span>\n  ),\n  avgCase: (\n    <span>\n      O(<em>n</em> log <em>n</em>)\n    </span>\n  ),\n  bestCase: (\n    <span>\n      O(<em>n</em> log <em>n</em>)\n    </span>\n  ),\n  space: (\n    <span>\n      O(<em>n</em>)\n    </span>\n  )\n};\nexport default MergeSort;"]},"metadata":{},"sourceType":"module"}